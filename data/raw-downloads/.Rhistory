}
class(cTables)
z <- unlist(cTables)
z
z[1]
for (t in cTables) {
print("Printing current values of " %&% t)
lookup <- acs.lookup(table.number = t)
vars <- lookup@results[,1] %&% "E"
pullVars <- c(pullVars, vars)
}
pullVars <- c()
for (t in cTables) {
print("Printing current values of " %&% t)
lookup <- acs.lookup(table.number = t)
vars <- lookup@results[,1] %&% "E"
pullVars <- c(pullVars, vars)
}
pullVars
for (t in cTables) {
print("Printing current values of " %&% t)
lookup <- acs.lookup(table.number = t)
vars <- lookup@results[,1] %&% "E"
print(vars)
pullVars <- c(pullVars, vars)
}
cTables <- c("B05006")
for (t in cTables) {
print("Printing current values of " %&% t)
lookup <- acs.lookup(table.number = t)
vars <- lookup@results[,1] %&% "E"
print(vars)
pullVars <- c(pullVars, vars)
}
pullvars
pullVars <- c()
pullVars
for (t in cTables) {
print("Printing current values of " %&% t)
lookup <- acs.lookup(table.number = t)
vars <- lookup@results[,1] %&% "E"
print(vars)
pullVars <<- c(pullVars, vars)
}
pullVars
cTables <- strsplit(sTables, " ")
@pullTables <- c("B05006_001E")
pullYear <- 2011
pullSpan <- 5
# Use the ACS package to look up the variable names for each table
pullVars <- c()
for (t in cTables) {
print("Printing current values of " %&% t)
lookup <- acs.lookup(table.number = t)
vars <- lookup@results[,1] %&% "E"
print(vars)
pullVars <<- c(pullVars, vars)
}
pullVars <- c()
for (t in cTables) {
print("Printing current values of " %&% t)
lookup <- acs.lookup(table.number = t)
vars <- lookup@results[,1] %&% "E"
print(vars)
pullVars <<- rbind(pullVars, vars)
}
pullVars <- c()
for (t in cTables) {
print("Printing current values of " %&% t)
lookup <- acs.lookup(table.number = t)
vars <- lookup@results[,1] %&% "E"
print(vars)
#pullVars <<- rbind(pullVars, vars)
}
pullVars <- c()
for (t in cTables) {
print("Printing current values of " %&% t)
lookup <- acs.lookup(table.number = t)
vars <- lookup@results[,1] %&% "E"
#print(vars)
#pullVars <<- rbind(pullVars, vars)
}
pullVars <- c()
for (t in cTables) {
print("Printing current values of " %&% t)
lookup <- acs.lookup(table.number = t)
#vars <- lookup@results[,1] %&% "E"
#print(vars)
#pullVars <<- rbind(pullVars, vars)
}
pullVars <- c()
for (t in cTables) {
print("Printing current values of " %&% t)
#lookup <- acs.lookup(table.number = t)
#vars <- lookup@results[,1] %&% "E"
#print(vars)
#pullVars <<- rbind(pullVars, vars)
}
pullVars <- c()
for (t in cTables) {
print("Printing current values of " %&% t)
lookup <- acs.lookup(table.number = t)
stop()
#vars <- lookup@results[,1] %&% "E"
#print(vars)
#pullVars <<- rbind(pullVars, vars)
}
for (t in cTables) {
print("Printing current values of " %&% t)
acs.lookup(table.number = t)
#vars <- lookup@results[,1] %&% "E"
#pullVars <<- rbind(pullVars, vars)
}
acs.lookup(table.number = "B07008")
z<-acs.lookup(table.number = "B07008")
z@results[,1]
z<-acs.lookup(table.number = "B07001")
z@results[,1]
for (t in cTables) {
print("Printing current value of t: " %&% t)
acs.lookup(table.number = t)
#vars <- lookup@results[,1] %&% "E"
#pullVars <<- rbind(pullVars, vars)
}
pullVars <- c()
for (t in cTables) {
print("Printing current value of t: " %&% t)
acs.lookup(table.number = t)
}
cTables <- cTables[1:2]
cTables
cTables <- c("B05006", "B06007")
for (t in cTables) {
print("Printing current value of t: " %&% t)
acs.lookup(table.number = t)
}
cTables <- c("B05006", "B06007", "B07001")
for (t in cTables) {
print("Printing current value of t: " %&% t)
acs.lookup(table.number = t)
}
cTables <- strsplit(sTables, " ")
cTables
class(cTables)
z <- unlist(cTables)
z
class(z)
cTables <- unlist(strsplit(sTables, " "))
for (t in cTables) {
print("Printing current value of t: " %&% t)
acs.lookup(table.number = t)
}
gc()
dev.off()
gc()
acsPull <- acs.fetch(endyear=2012, span = 5, geography = myGeo_TractLvl, table.number=myTables, key = apiKey)
#---------------------------------------------------------------
## This file makes custom pulls of ACS data using the Census API
#---------------------------------------------------------------
# See Census API documentation at http://www.census.gov/developers/
# See Census ACS documentation at http://www.census.gov/acs/
# Pattern of API pulls is http://api.census.gov/data/2011/acs5?key=<API Key>&get=B05006_001E&for=tract:010100&in=state:17+county:031
# TO DO
# 2. Need to specify all variables, not just table names -- pretty inconvenient ... could use the ACS package for this?
# 3. Try to replace all of this with acs package operations ... currently, the ACS package isn't working for other years
library("acs") # for pulling data
library("plyr") # for renaming variables
library("RCurl")
library("jsonlite")
"%&%" <- function(...){paste(..., sep="")}
apiKey <- "8b24ac0e60205471267cecd02fa45e7575082313" # This is Nick Mader's key
/*----------------*/
/*----------------*/
/* USE CENSUS API */
/*----------------*/
/*----------------*/
# Set up the Pull Request
sTables <- "B05006 B06007 B07001 B07008 B08141 B08301 B09001 B09002 B09010 B10057 B11001 B11003 B11004 B11016 B13002 B13012 B13014 B13016 B15001 B15002 B16001 B17022 B17024 B17026 B23001 B23007 B23008 B25070 B25091 B25115 C17002 C24010"
pullTables <- gsub(" ", ",", sTables)
cTables <- unlist(strsplit(sTables, " "))
@pullTables <- c("B05006_001E")
pullYear <- 2011
pullSpan <- 5
pullYear <- 2011
pullSpan <- 5
myCounties <- c("Cook County", "DuPage County", "Kane County", "Lake County", "McHenry County", "Will County") # This represents Cook County--the seat of Chicago--as well as the "collar" counties - http://en.wikipedia.org/wiki/Collar_counties
myTables <- c("B17026")
myGeo_TractLvl  <- geo.make(state=c("IL"), county=myCounties, tract=c("*"))
pullVarsReq <- paste(pullVars, collapse = "")
pullTables <- "B17036"
pullRequest <- paste("http://api.census.gov/data/", pullYear, "/acs", pullSpan, "?key=", apiKey, "&get=", pullTables, "&for=tract:*&in=state:17+county:031", sep="") # Illinois' FIPs code is 17, and Cook County is FIPS code 031
pullRequest
pullVras
pullTables <- c("B05006_001E")
myCounties <- c("Cook County", "DuPage County", "Kane County", "Lake County", "McHenry County", "Will County") # This represents Cook County--the seat of Chicago--as well as the "collar" counties - http://en.wikipedia.org/wiki/Collar_counties
myTables <- c("B17026")
myGeo_TractLvl  <- geo.make(state=c("IL"), county=myCounties, tract=c("*"))
myGeo_CountyLvl <- geo.make(state=c("IL"), county=myCounties)
# Check/inspect geographies
geo.lookup(state=c("IL"), county=c(""))
geo.lookup(state=c("IL"), county=myCounties)
# Generate Pulls
acsPull <- acs.fetch(endyear=2011, span = 5, geography = myGeo_TractLvl, table.number=myTables, key = apiKey)
acsEstimates <- estimate(acsPull)
acsEstimates
str(acsEstimates)
colnames(acsEstimates)
rownames(acsEstimates)
class(acsEstimates)
head(acsEstimates)
acsPull2011 <- acs.fetch(endyear=2011, span = 5, geography = myGeo_TractLvl, table.number=myTables, key = apiKey)
acsEstimates2011 <- estimate(acsPull2011)
acsPull2012 <- acs.fetch(endyear=2012, span = 5, geography = myGeo_TractLvl, table.number=myTables, key = apiKey)
acsEstimates2012 <- estimate(acsPull2012)
head(acsEstimates2011)
head(acsEstimates2012)
pullReqest
pullRequest
class(acsEstimates2012)
acsEstimates2012$A <- acsEstimates$B17026_001 + 100
acsEstimates$B17026_001 + 100
acsEstimates[,"B17026_001"] + 100
tail(acsEstimates2013)
tail(acsEstimates2012)
acsEstimates2012[,"B17026_001"] + 100
tail(acsEstimates2012)
acsPull2011_1yrCounty <- acs.fetch(endyear=2011, span = 1, geography = myGeo_CountyLvl, table.number=myTables, key = apiKey)
acsEstimates2011_1yrCount <- estimate(acsPull2011_1yrCounty) # acs package warning for spans other than 5: As of the date of this version of the acs package Census API provides only limited data
acsPull2011_1yrCounty <- acs.fetch(endyear=2011, span = 1, geography = myGeo_CountyLvl, table.number=myTables, key = apiKey)
geo.lookup(state=c("IL"), county=myCounties)
acs.lookup
acsPull2011_1yrCounty <- acs.fetch(endyear=2011, span = 1, geography = myGeo_CountyLvl, table.number="DP02", key = apiKey)
acsPull2011_1yrCounty <- acs.fetch(endyear=2012, span = 1, geography = myGeo_CountyLvl, table.number="DP02", key = apiKey)
acsPull2011_1yrCounty
acsPull2011_1yrCounty <- acs.fetch(endyear=2012, span = 1, geography = myGeo_CountyLvl, table.number="DP02_0001", key = apiKey)
acsPull2008 <- acs.fetch(endyear=2008, span = 5, geography = myGeo_TractLvl, table.number=myTables, key = apiKey)
acsEstimates2008 <- estimate(acsPull2008)
acsEstimates2008
acsPull2008
acsPull2009 <- acs.fetch(endyear=2009, span = 5, geography = myGeo_TractLvl, table.number=myTables, key = apiKey)
acsEstimates2009 <- estimate(acsPull2009)
acsPull2009
acsPull2010 <- acs.fetch(endyear=2010, span = 5, geography = myGeo_TractLvl, table.number=myTables, key = apiKey)
?ls
?regex
View(df)
source('~/.active-rstudio-document', echo=TRUE)
mySumFn(5)
mySumFn(5, 6)
myResult <- myFumFn(3, 4)
myResult <- mySumFn(3, 4)
myResult
pullYear <- "2012"
pullSpan  <- 1
pullState <- "Illinois"
pullCtny  <- c("Cook County", "Will County", "Lake County", "Kane County", "McHenry County", "DuPage County")  ## To avoid potentially non-unique pulls, "County" should be specified here
pullTract <- "*"
pullTables <- unlist(strsplit("B01001 B01001A B01001B B01001C B01001D B01001E B01001F B01001G B01001H B01001I B08006 B08008 B08011 B08012 B08013 B15001 B15002 B17001 B12001 B12002 B12006 B17003 B17004 B17005 B19215 B19216 B14004 B14005 B05003 B23001 B23018 B23022 B24012 B24022 B24042 B24080 B24082 B24090 C24010 C24020 C24040 B11001 B11003 B11004 B13002 B13012 B13014 B13016 B17022 B23007 B23008 B25115", split= " "))
# Look up geography codes using the acs package
pullSt <- "IL"
Meta <- read.csv(url(paste0("http://www2.census.gov/acs", pullYear, "_", pullSpan, "yr/summaryfile/Sequence_Number_and_Table_Number_Lookup.txt")), header = TRUE)
View(Meta)
install.packages("shinyapps")
install.packages("devtools")
install.packages("shinyapps")
devtools::install_github('rstudio/shinyapps')
shinyapps::setAccountInfo(name="nsmader", token="36221D8E91443FB81B18595EF45743CF", secret="cxnSycMlXDCXj6sbJUTzzMl3F5RUFheHa4oDGlkZ")
source('~/GitHub/acs-shop-cook-serve/scripts/call_getAcs.r', echo=TRUE)
pullYear = 2011; pullSpan = 1; pullState = "Illinois"; pullSt = "IL"; pullCounties = myCounties; pullTables = myTables; dirGeoLab = dirSave; dirDl = dirDl; downloadData = TRUE #"B19215"
print(paste0("Downloading and extracting ACS ", pullYear, " ", pullSpan, " year data for ", "state =  ", pullState, " and Counties = ", paste(pullCounties, collapse = ", ")))
CountyLookup <- geo.lookup(state=pullSt, county=pullCounties)
pullCountyCodes <- CountyLookup$county[!is.na(CountyLookup$county)]
#----------------------------
### Download and Extract Data
#----------------------------
# Get metadata
if (pullYear >= 2010) {
metaPath   <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/Sequence_Number_and_Table_Number_Lookup.txt")
remoteData <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/", pullYear, "_ACSSF_By_State_All_Tables/", pullState, "_All_Geographies.zip")
geoFileExt <- "csv"
} else if (pullYear == 2009) {
metaPath   <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/UserTools/merge_5_6.txt")
remoteData <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/Entire_States/Illinois.zip")
geoFileExt <- "txt"
} else if (pullYear == 2008) {
metaPath   <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/merge_5_6.xls")
remoteData <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/Illinois/")
geoFileExt <- "txt"
} else if (pullYear == 2007) {
metaPath   <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/merge_5_6_final.xls")
remoteData <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/Illinois/")
geoFileExt <- "txt"
} else if (pullYear == 2006) {
metaPath   <- paste0("acs", pullYear, "/summaryfile/merge_5_6_final.xls")
remoteData <- paste0("acs", pullYear, "/summaryfile/Illinois/")
geoFileExt <- "txt"
}
print(paste0("metaPath = ", metaPath))
metaExt <- substr(metaPath, nchar(metaPath) - 2, nchar(metaPath))
if (metaExt == "txt") {
Meta <- read.csv(url(paste0("http://www2.census.gov/", metaPath)), header = TRUE)
} else if (metaExt == "xls") {
Meta <- read.xls(paste0("http://www2.census.gov/", metaPath))
}
colnames(Meta) <- c("File.ID", "Table.ID", "Sequence.Number", "Line.Number", "Start.Position", "Total.Cells.in.Table", "Total.Cells.in.Sequence", "Table.Title", "Subject.Area")
# Get data
myFileName <- paste0("/ACS_", pullYear, "_", pullSpan, "Year_", pullSt, ".zip")
myPathFileName <- paste0(dirDl, myFileName)
remoteDataName <- paste0("http://www2.census.gov/", remoteData)
if (downloadData == TRUE & !file.exists(myPathFileName)) {
print(paste0("Downloading data: ", myFileName, " from remoteDataName"))
download.file(remoteDataName, myPathFileName)
unzip(zipfile = myPathFileName)
# NSM: am having problems explicitly feeding an argument to "exdir" for this function.
# For now, it's using the current working directory as the default
}
# Get geodata
geoLabels <- read.csv(paste0(dirGeoLab, "/geofile-fields.csv"), header=T)
# created by hand from documentation
if (geoFileExt == "csv") {
geoFile <- read.csv(paste0(dirDl, "/g", pullYear, pullSpan, tolower(pullSt), ".", geoFileExt), header=F)
} else if (geoFileExt == "txt") {
geoFile <- read.delim(paste0(dirDl, "/g", pullYear, pullSpan, tolower(pullSt), ".", geoFileExt), header=F)
}
colnames(geoFile) <- geoLabels$geoField
#----------------------------
### Set Up Metadata for Files
#----------------------------
# Identify the sequence number corresponding to each table that has been specified
Meta$Line.Number <- as.numeric(levels(Meta$Line.Number)[Meta$Line.Number])
# Convert Line.Number from a factor to numeric, using the levels of the factor. (The reason that Line.Number comes in as a factor is because it has non-numeric values, and read.csv handles this by creating a factor.)
Meta$elemName <- paste0(Meta$Table.ID, "_", Meta$Line.Number)
# Subset the metafile to only information pertaining to table columns
myMeta <- Meta[!is.na(Meta$Line.Number) & Meta$Line.Number %% 1 == 0, ]; # rm(Meta)
myLogRecNos <- geoFile$LOGRECNO[geoFile$COUNTY %in% pullCountyCodes & geoFile$SUMLEVEL == 50]
# XXX Implicitly only allows draws of county data. Need to update this when going to other geographies
seqFile.dict <- list(c("FILEID", "File Identification"),
c("FILETYPE", "File Type"),
c("STUSAB", "State/U.S.-Abbreviation (USPS)"),
c("CHARITER", "Character Iteration"),
c("SEQUENCE", "Sequence Number"),
c("LOGRECNO", "Logical Record Number"))
seqFile.idVars <- sapply(seqFile.dict, function(m) m[1])
seqFile.mergeVars <- c("FILEID", "FILETYPE", "STUSAB", "LOGRECNO")
#-----------------------------------
### Select Tables and Merge Together
#-----------------------------------
for (t in pullTables) {
print("    Extracting table " %&% t)
# Identify the sequence file we need to open
t.seqNum <- myMeta[myMeta$Table.ID == t, "Sequence.Number"][1]
# We can take the first element, since all of the returned sequence numbers
# should be the same
# Get meta data on the sequence file
seqFile.elemNames <- myMeta$elemName[myMeta$Sequence.Number == t.seqNum]
mySeqColNames <- c(seqFile.idVars, seqFile.elemNames)
# Get meta data on the table we'll draw from the sequence file
t.elemNames <- myMeta$elemName[myMeta$Table.ID == t]
t.meta <- acs.lookup(endyear = 2012, span = pullSpan, dataset = "acs", table.name = t)
# using year 2011 since the ACS package hasn't been updated to expect 2012
# and throws an error. 2011 gets us the same results in terms of table information.
t.dataLabels <- t.meta@results$variable.name[t.meta@results$table.number == t]
# Note: need to ensure subsetting to exactly rows equal to t since acs.lookup returns
# all table matches to the search. Thus, it returns meta data for "B01001A" when searching
# for "B01001".
t.dataDict <- cbind(t.elemNames, t.dataLabels)
# Open the sequence file and apply headers
mySeq <- read.csv(paste0(dirDl, "/e", pullYear, pullSpan, tolower(pullSt), sprintf("%04d", t.seqNum), "000.txt"), header=FALSE)
colnames(mySeq) <- mySeqColNames
# Pull the tables and geographies of interest
myTable <- mySeq[mySeq$LOGRECNO %in% myLogRecNos, c(seqFile.mergeVars, t.elemNames) ]
# Compile all requested table information
if (t == pullTables[1]) {
myResults <- myTable
myDataDict <- t.dataDict
} else {
myResults <- merge(x=myResults, y=myTable, by=c("FILEID", "FILETYPE", "STUSAB", "LOGRECNO"))
myDataDict <- rbind(myDataDict, t.dataDict)
}
#print(paste0("        Completed running ", t))
}
myResults$County <- pullCounties
colnames(myDataDict) <- c("Table Element", "Element Label")
myResults$County <- pullCounties
colnames(myDataDict) <- c("Table Element", "Element Label")
str(myDataDict)
str(t.dataDict)
dim(t.elemNames)
length(t.elemNames)
length(t.dataLabels)
t.dataDict <- cbind(t.elemNames, t.dataLabels)
#Test code for if we want to run within this function
pullYear = 2011; pullSpan = 1; pullState = "Illinois"; pullSt = "IL"; pullCounties = myCounties; pullTables = "B19215"; dirGeoLab = dirSave; dirDl = dirDl; downloadData = TRUE # myTables
print(paste0("Downloading and extracting ACS ", pullYear, " ", pullSpan, " year data for ", "state =  ", pullState, " and Counties = ", paste(pullCounties, collapse = ", ")))
CountyLookup <- geo.lookup(state=pullSt, county=pullCounties)
pullCountyCodes <- CountyLookup$county[!is.na(CountyLookup$county)]
#----------------------------
### Download and Extract Data
#----------------------------
# Get metadata
if (pullYear >= 2010) {
metaPath   <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/Sequence_Number_and_Table_Number_Lookup.txt")
remoteData <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/", pullYear, "_ACSSF_By_State_All_Tables/", pullState, "_All_Geographies.zip")
geoFileExt <- "csv"
} else if (pullYear == 2009) {
metaPath   <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/UserTools/merge_5_6.txt")
remoteData <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/Entire_States/Illinois.zip")
geoFileExt <- "txt"
} else if (pullYear == 2008) {
metaPath   <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/merge_5_6.xls")
remoteData <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/Illinois/")
geoFileExt <- "txt"
} else if (pullYear == 2007) {
metaPath   <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/merge_5_6_final.xls")
remoteData <- paste0("acs", pullYear, "_", pullSpan, "yr/summaryfile/Illinois/")
geoFileExt <- "txt"
} else if (pullYear == 2006) {
metaPath   <- paste0("acs", pullYear, "/summaryfile/merge_5_6_final.xls")
remoteData <- paste0("acs", pullYear, "/summaryfile/Illinois/")
geoFileExt <- "txt"
}
print(paste0("metaPath = ", metaPath))
metaExt <- substr(metaPath, nchar(metaPath) - 2, nchar(metaPath))
if (metaExt == "txt") {
Meta <- read.csv(url(paste0("http://www2.census.gov/", metaPath)), header = TRUE)
} else if (metaExt == "xls") {
Meta <- read.xls(paste0("http://www2.census.gov/", metaPath))
}
colnames(Meta) <- c("File.ID", "Table.ID", "Sequence.Number", "Line.Number", "Start.Position", "Total.Cells.in.Table", "Total.Cells.in.Sequence", "Table.Title", "Subject.Area")
# Get data
myFileName <- paste0("/ACS_", pullYear, "_", pullSpan, "Year_", pullSt, ".zip")
myPathFileName <- paste0(dirDl, myFileName)
remoteDataName <- paste0("http://www2.census.gov/", remoteData)
if (downloadData == TRUE & !file.exists(myPathFileName)) {
print(paste0("Downloading data: ", myFileName, " from remoteDataName"))
download.file(remoteDataName, myPathFileName)
unzip(zipfile = myPathFileName)
# NSM: am having problems explicitly feeding an argument to "exdir" for this function.
# For now, it's using the current working directory as the default
}
# Get geodata
geoLabels <- read.csv(paste0(dirGeoLab, "/geofile-fields.csv"), header=T)
# created by hand from documentation
if (geoFileExt == "csv") {
geoFile <- read.csv(paste0(dirDl, "/g", pullYear, pullSpan, tolower(pullSt), ".", geoFileExt), header=F)
} else if (geoFileExt == "txt") {
geoFile <- read.delim(paste0(dirDl, "/g", pullYear, pullSpan, tolower(pullSt), ".", geoFileExt), header=F)
}
colnames(geoFile) <- geoLabels$geoField
#----------------------------
### Set Up Metadata for Files
#----------------------------
# Identify the sequence number corresponding to each table that has been specified
Meta$Line.Number <- as.numeric(levels(Meta$Line.Number)[Meta$Line.Number])
# Convert Line.Number from a factor to numeric, using the levels of the factor. (The reason that Line.Number comes in as a factor is because it has non-numeric values, and read.csv handles this by creating a factor.)
Meta$elemName <- paste0(Meta$Table.ID, "_", Meta$Line.Number)
# Subset the metafile to only information pertaining to table columns
myMeta <- Meta[!is.na(Meta$Line.Number) & Meta$Line.Number %% 1 == 0, ]; # rm(Meta)
myLogRecNos <- geoFile$LOGRECNO[geoFile$COUNTY %in% pullCountyCodes & geoFile$SUMLEVEL == 50]
# XXX Implicitly only allows draws of county data. Need to update this when going to other geographies
seqFile.dict <- list(c("FILEID", "File Identification"),
c("FILETYPE", "File Type"),
c("STUSAB", "State/U.S.-Abbreviation (USPS)"),
c("CHARITER", "Character Iteration"),
c("SEQUENCE", "Sequence Number"),
c("LOGRECNO", "Logical Record Number"))
seqFile.idVars <- sapply(seqFile.dict, function(m) m[1])
seqFile.mergeVars <- c("FILEID", "FILETYPE", "STUSAB", "LOGRECNO")
#-----------------------------------
### Select Tables and Merge Together
#-----------------------------------
for (t in pullTables) {
print("    Extracting table " %&% t)
# Identify the sequence file we need to open
t.seqNum <- myMeta[myMeta$Table.ID == t, "Sequence.Number"][1]
# We can take the first element, since all of the returned sequence numbers
# should be the same
# Get meta data on the sequence file
seqFile.elemNames <- myMeta$elemName[myMeta$Sequence.Number == t.seqNum]
mySeqColNames <- c(seqFile.idVars, seqFile.elemNames)
# Get meta data on the table we'll draw from the sequence file
t.elemNames <- myMeta$elemName[myMeta$Table.ID == t]
t.meta <- acs.lookup(endyear = 2012, span = pullSpan, dataset = "acs", table.name = t)
# using year 2011 since the ACS package hasn't been updated to expect 2012
# and throws an error. 2011 gets us the same results in terms of table information.
t.dataLabels <- t.meta@results$variable.name[t.meta@results$table.number == t]
# Note: need to ensure subsetting to exactly rows equal to t since acs.lookup returns
# all table matches to the search. Thus, it returns meta data for "B01001A" when searching
# for "B01001".
t.dataDict <- cbind(t.elemNames, t.dataLabels)
# Open the sequence file and apply headers
mySeq <- read.csv(paste0(dirDl, "/e", pullYear, pullSpan, tolower(pullSt), sprintf("%04d", t.seqNum), "000.txt"), header=FALSE)
colnames(mySeq) <- mySeqColNames
# Pull the tables and geographies of interest
myTable <- mySeq[mySeq$LOGRECNO %in% myLogRecNos, c(seqFile.mergeVars, t.elemNames) ]
# Compile all requested table information
if (t == pullTables[1]) {
myResults <- myTable
myDataDict <- t.dataDict
} else {
myResults <- merge(x=myResults, y=myTable, by=c("FILEID", "FILETYPE", "STUSAB", "LOGRECNO"))
myDataDict <- rbind(myDataDict, t.dataDict)
}
#print(paste0("        Completed running ", t))
}
myResults$County <- pullCounties
colnames(myDataDict) <- c("Table Element", "Element Label")
t.dataDict <- cbind(t.elemNames, t.dataLabels)
length(t.elemNames)
length(t.dataLabels)
t.elemNames
t.dataLabels
